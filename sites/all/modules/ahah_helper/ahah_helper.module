<?php
// $Id: ahah_helper.module,v 1.1 2008/08/29 18:58:21 wimleers Exp $

define('AHAH_HELPER_CALLBACK', 'ahah_helper/');


//----------------------------------------------------------------------------
// Drupal core hooks.

/**
 * Implementation of hook_menu().
 */
function ahah_helper_menu() {
  $items[AHAH_HELPER_CALLBACK . '%ahah_helper_form_item'] = array(
    'page callback'    => 'ahah_helper_render',
    'page arguments'   => array(1),
    'access callback'  => TRUE,
    'type'             => MENU_CALLBACK,
  );

  return $items;
}

//----------------------------------------------------------------------------
// Menu system callbacks.

/**
 * Wildcard loader for form items; assumes that a passed form item also exists.
 */
function ahah_helper_form_item_load($form_item) {
  return $form_item;
}


//----------------------------------------------------------------------------
// Exposed functions.

/**
 * Builds the path to render a certain form item.
 *
 * @param $parents
 *   An array of parrents by which the wanted form item is identified.
 */
function ahah_helper_path($parents = FALSE) {
  if (is_array($parents)) {
    $path = AHAH_HELPER_CALLBACK . implode('][', $parents);
  }
  else {
    $path = AHAH_HELPER_CALLBACK . '<form>';
  }

  return $path;
}

/**
 * This function records in which file your form definition lives and which
 * file therefor should be loaded in case of an AHAH callback.
 *
 * @param $form_state
 *   The form state variable.
 */
function ahah_helper_register(&$form, &$form_state) {
  // This is an AHAH-driven form, so enable caching.
  $form['#cache'] = TRUE;

  // Register the file.
  if (!isset($form_state['storage']['#file'])) {
    $menu_item = menu_get_item();
    if ($menu_item['file']) {
      $form_state['storage']['#file'] = $menu_item['file'];
    }
  }

  // Add our JS file, which has some Drupal core JS overrides.
  drupal_add_js(drupal_get_path('module', 'ahah_helper') . '/ahah_helper.js', 'footer');
}

/**
 * Submit callback; for any button that's used when JS is disabled (i.e. to
 * trigger an update of the displayed fields: add/remove fields).
 */
function ahah_helper_generic_submit($form, &$form_state) {
  $form_state['rebuild'] = TRUE;
}

/**
 * Given a POST of a Drupal form (with both a form_id and a form_build_id
 * defined), this function rebuilds the form and then only renders the given
 * form item. If no form item is given, the entire form is rendered.
 *
 * Is used directly in a menu callback in ahah_helper's sole menu item. Can
 * also be used in more advanced menu callbacks, for example to render
 * multiple form items of the same form and return them separately.
 *
 * @param $parents
 */
function ahah_helper_render($form_item_to_render = FALSE) {
  $form_state = array('submitted' => FALSE, 'values' => $_POST);
  $form_id = $_POST['form_id'];
  $form_build_id = $_POST['form_build_id'];

  // We use the form cache, but solely to retrieve $form_state['storage'] and
  // $form['#parameters'].
  // The ahah_helper module has set $form_state['storage']['#file'] to know
  // which file should be loaded. This is necessary because we'll use the form
  // definition itself rather than the cached $form.
  $form = form_get_cache($form_build_id, $form_state);
  if (isset($form_state['storage']['#file'])) {
    require_once($form_state['storage']['#file']);
  }

  // Detect which form items already exist, so we can detect form items that
  // will be displayed to the user for the first time and disable validation
  // for them.
  $existing_form_items = (isset($form_state['storage']['#existing_form_items'])) ? $form_state['storage']['#existing_form_items'] : array();
  _ahah_helper_detect_form_items($form, $existing_form_items);
  $form_state['storage']['#existing_form_items'] = $existing_form_items;

  // Rebuild the form.
  $args = $form['#parameters'];
  array_shift($args); // We don't have to pass the form id again.
  $form = drupal_update_form($form_id, &$form_state, $args, $form_build_id, $form_item_to_render, $existing_form_items);
  $form['#programmed'] = FALSE;

  // We *do* save the form to the cache, so modules that use "D6 core style"
  // AHAH updates still work.
  form_set_cache($form_build_id, $form, $form_state);

  // Get the JS settings so we can merge them.
  $javascript = drupal_add_js(NULL, NULL, 'header');

  // Get the form item that we will render.
  $form_item = _ahah_helper_get_form_item($form, $form_item_to_render);

  // Only keep relevant errors, if any.
  $errors = array_values(_ahah_helper_collect_relevant_errors($form_item));
  $_SESSION['messages']['error'] = $errors;
  if (count($errors) == 0) {
    unset($_SESSION['messages']['error']);
  }

  drupal_json(array(
    'status'   => TRUE,
    'data'     => theme('status_messages') . drupal_render($form_item),
    'settings' => call_user_func_array('array_merge_recursive', $javascript['setting']),
  ));
}

/**
 * Retrieves a form, caches it and builds the form.
 *
 * Almost a clone of drupal_rebuild_form, but not entirely: we don't process
 * the form, we only rebuild it (thereby NOT invoking validate and submit
 * handlers)
 */
function drupal_update_form($form_id, &$form_state, $args, $form_build_id, $form_item_to_render = FALSE, $existing_form_items = array()) {
  // Remove the first argument. This is $form_id.when called from
  // drupal_get_form and the original $form_state when called from some AHAH
  // callback. Neither is needed. After that, put in the current state.
  $args[0] = &$form_state;
  // And the form_id.
  array_unshift($args, $form_id);
  $form = call_user_func_array('drupal_retrieve_form', $args);

  $form['#build_id'] = $form_build_id;
  drupal_prepare_form($form_id, $form, $form_state);

  // Now, we cache the form structure so it can be retrieved later for
  // validation. If $form_state['storage'] is populated, we'll also cache
  // it so that it can be used to resume complex multi-step processes.
  form_set_cache($form_build_id, $form, $form_state);

  // Set POST data.
  $form['#post'] = $_POST;
  $form['#programmed'] = TRUE;

  // Build the form, so we can render it, or continue processing it (call
  // validate and/or submit handlers)
  $form = form_builder($form_id, $form, &$form_state);

  // Disable validation for form items that are being displayed for the first
  // time.
  _ahah_helper_new_form_items_disable_validation($form, $existing_form_items);

  // Validate the form.
  drupal_validate_form($form_id, $form, $form_state);

  // We validated the form, but we'll only prevent submit handlers from being
  // executed if there were validation errors relevant to the form item that
  // will be rendered!
  // Call submit handlers. Only designed to be used for submit handlers that
  // trigger partial updates of the form, not for an actual submit.
  $errors = _ahah_helper_collect_relevant_errors(_ahah_helper_get_form_item($form, $form_item_to_render));
  if (!$errors && count($form_state['submit_handlers'])) {
    form_execute_handlers('submit', $form, &$form_state);

    $form = call_user_func_array('drupal_retrieve_form', $args);

    $form['#build_id'] = $form_build_id;
    drupal_prepare_form($form_id, $form, $form_state);

    // Now, we cache the form structure so it can be retrieved later for
    // validation. If $form_state['storage'] is populated, we'll also cache
    // it so that it can be used to resume complex multi-step processes.
    form_set_cache($form_build_id, $form, $form_state);

    // Set POST data.
    $form['#post'] = $_POST;
    $form['#programmed'] = TRUE;

    // Build the form.
    $form = form_builder($form_id, $form, &$form_state);
  }

  return $form;
}


//----------------------------------------------------------------------------
// Private functions.

/**
 * Given a form by reference and an array of parents, return the corresponding
 * form item by reference. If $parents is FALSE or '<form>', the entire $form
 * array will be returned. If it doesn't exist, return NULL.
 *
 * @param $form
 *   A form.
 * @param $parents
 *   An array of parrents by which the wanted form item is identified, or
 *   imploded with ']['.
 * @return
 *   The wanted form item.
 */
function &_ahah_helper_get_form_item(&$form, $parents = FALSE) {
  if ($parents == '<form>' || !$parents) {
    return $form;
  }

  // Allow $parents to be either an array of the element's parents or the name
  // of an element.
  if (is_string($parents)) {
    if (strpos($parents, ']') !== FALSE) {
      $parents = explode('][', $parents);
    }
    else {
      $parents = array($parents);
    }
  }

  // Recursively seek the form element.
  if (count($parents)) {
    $parent = array_shift($parents);
    if (isset($form[$parent])) {
      return _ahah_helper_get_form_item(&$form[$parent], $parents);
    }
    else {
      return NULL;
    }
  }
  else {
    return $form;
  }
}

/**
 * Helper function to detect form items. If you want to check if a form item
 * does not exist, you should verify that it doesn't exist in the
 * $existing_form_items parameter.
 *
 * @param $form
 *   A form.
 * @param $existing_form_items
 *   An array of existing form items, basically a clone of $form, but without
 *   the form items' properties and previously existing, but now deleted items
 *   are persistent.
 */
function _ahah_helper_detect_form_items($form, &$existing_form_items) {
  foreach(element_children($form) as $child) {
    $existing_form_items[$child]['exists'] = TRUE;
    _ahah_helper_detect_form_items($form[$child], &$existing_form_items[$child]);
  }
}

/**
 * Helper function to disable form items for form items that exist for the
 * first time in the form.
 *
 * @param $form
 *   A form.
 * @param $existing_form_items
 *   An array of existing form items, as generated by
 *   _ahah_helper_detect_form_items().
 */
function _ahah_helper_new_form_items_disable_validation(&$form, $existing_form_items) {
  foreach (element_children($form) as $child) {
    if (!isset($existing_form_items[$child]['exists'])) {
      $form[$child]['#validated'] = TRUE;
      $form[$child]['#first_time'] = TRUE;
    }
    _ahah_helper_new_form_items_disable_validation(&$form[$child], $existing_form_items[$child]);
  }
}

/**
 * Helper function to filter get all form errors that are relevant to the
 * given form item and its children.
 *
 * @param $form_item
 *   The form item for which to collect the relevant errors.
 * @return
 *   An array of errors, if any.
 */
function _ahah_helper_collect_relevant_errors($form_item) {
  if (empty($form_item)) {
    return array();
  }

  $errors = array();
  $error = form_get_error($form_item);

  if ($error) {
    $key = implode('][', $form_item['#parents']);
    $errors[$key] = $error;
  }
  foreach (element_children($form_item) as $child) {
    $errors = array_merge($errors, _ahah_helper_collect_relevant_errors($form_item[$child]));
  }
  return $errors;
}
